"""
각 예시에 대해 정렬된 arr
[[1, 4], [2, 3], [3, 2], [4, 1], [5, 5]]
[[1, 4], [2, 5], [3, 6], [4, 2], [5, 7], [6, 1], [7, 3]]

앞에서부터 순차적으로 봤을 때, 두번째 원소가 감소하는 수열 중 최대 길이를 찾는 문제. 즉,
4,3,2,1,5 -> 4,3,2,1
4,5,6,2,7,1,3, -> (4,5,6), 2, 1

observ 1 : ai가 선택되기 위한 필요조건
a1, a2, ..., ai-1에게는 이미 하나 진 상태(첫번째 원소에 대해 정렬)이므로, min(a1, a2, ..., ai-1) > ai 여야 함

stack : max_length
4 : 1
4 1 : 2
4 3 : 2
4 3 2: 3

stack의 top 보다 작으면 push
단 더 크면,

greedy : 이후에 나오는 수 중에서 이전 원소보다 작은 것을 바로 선택

4,1,3,2

4
4 1
4 3
4 3 2

"""

# import sys
# input =

for _ in range(int(input())):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]

    arr.sort()
    print(arr)